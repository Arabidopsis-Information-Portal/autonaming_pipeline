#!/usr/local/bin/perl

=head1 NAME
    
    .pl
    
=head1 USAGE

    .pl [-]-results_path <results_path> [-]-infile <infile> [-]-project_code <project_code>

=head1 REQUIRED ARGUMENTS

=over

=item [-]-infile  <infile>

file containing a full path list of all multifasta files to process through the pipeline.

=for Euclid:
    infile.type: readable

=item [-]-results_path  <results_path>

full path to the location results files should be written

=for Euclid:
    results_path.type: string

=item [-]-project_code  <project_code>

charge code for using the grid

=for Euclid:
    project_code.type: string
    
=back

=head1 OPTIONS

=over

=item [-]-queue  <queue>

Specifies a queue for the grid jobs
   
=for Euclid:
    queue.type: string

=item [-]-config  <config>

Specifies a config file (ini format) used to overide standard pipeline configurations and default parameters

=for Euclid:
	config.type: string
	
=back

=head1 DESCRIPTION

This script will run .

=cut

use strict;
use Config::IniFiles;
use FindBin;
require "$FindBin::Bin/mg_lib.pl";

use lib "/usr/local/devel/VIRIFX/software/VGD/lib";
use Getopt::Euclid 0.2.4 qw(:vars);

my $list = $ARGV_infile;
my $results_path = $ARGV_results_path;
my $queue = $ARGV_queue;
my $config = $ARGV_config;
my $grid_code = $ARGV_project_code;

my $program_path = $0;
my @prog = split '/', $program_path;
my $program = pop @prog;
my @files;

my $cfg;
if ($config) {
	$cfg = Config::IniFiles->new( -file => "$config" ) || die "cannot parse user suplied config file.\n";
}
my $path = &get_lib_path($cfg);

my $snapshot_dir;
if ($cfg->val('UNIREF', 'snapshot_dir')) {
	$snapshot_dir = $cfg->val('UNIREF', 'snapshot_dir');
} else {
	$snapshot_dir = "/usr/local/projects/DB/MGX/mgx-prok-annotation/20101221";
}

my $cat = "/bin/cat";
my $sort = "/bin/sort";
my $annotate = "$path/bin/camera_annotate_from_sorted_table.pl";
my $synonyms = "$snapshot_dir/synonyms.tab";
my $shell_config = "$FindBin::Bin/etc/shell.config";
my $shell_template = &write_shell_template($shell_config,$path,$results_path);

open (IN, $list) || die "Cannot open $list. $!\n";
while (<IN>) {
	chomp $_;
	if (-e $_) {
		push @files, $_;
	} else {
		die "$_ does not exist.\n";
	}
}
close IN;

my $cat_file = "$results_path/camera_annotation_parser.raw.combined.out";
my $sort_file = "$cat_file.sorted";
my $rules_file = "$cat_file.rules";
my $unused = "$cat_file.apparently_unused";

my $cat_cmd = "$cat " . join(" ", @files) . " > $cat_file";
print "$cat_cmd\n";
system $cat_cmd;

my $sort_cmd = "$sort  --key=1,1 -T ./ -S 1G -d -o $sort_file $cat_file";
print "$sort_cmd\n";
system $sort_cmd;

my $shell_text = &read_shell_config($shell_template);
my $shell_file = "$results_path/annotate.sh";
my $annotate_cmd = "$annotate --input $sort_file --output $unused --synonyms $synonyms > $rules_file";
$shell_text .= $annotate_cmd;
print "$shell_text\n";

&write_bash_shell_script($shell_file,$shell_text);

system $shell_file;

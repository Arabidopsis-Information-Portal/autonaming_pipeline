#!/usr/local/bin/perl

=head1 NAME
    
    mg_standalone_pipeline.pl
    
=head1 USAGE

    mg_standalone_pipeline.pl [-]-results_path <results_path> [-]-infile <infile> [-]-project_code <project_code>

=head1 REQUIRED ARGUMENTS

=over

=item [-]-infile  <infile>

file containing a full path list of all multifasta files to process through the pipeline.

=for Euclid:
    infile.type: readable

=item [-]-results_path  <results_path>

full path to the location results files should be written

=for Euclid:
    results_path.type: string

=item [-]-project_code  <project_code>

charge code for using the grid

=for Euclid:
    project_code.type: string
        
=back

=head1 OPTIONS

=over

=item [-]-queue  <queue>

Specifies a queue for the grid jobs
   
=for Euclid:
    queue.type: string

=item [-]-config  <config>

Specifies a config file (ini format) used to overide standard pipeline configurations and default parameters

=for Euclid:
	config.type: string

=item [-]-project_tag  <project_tag>

=for Euclid:
	project_tag.type: string
	
=back

=head1 DESCRIPTION

This script will run a stand alone version of the metagenomics prokaryotic annotation pipeline.

=cut

use strict;
use Config::IniFiles;
use FindBin;
require "$FindBin::Bin/mg_lib.pl";

use lib "/usr/local/devel/VIRIFX/software/VGD/lib";
use Getopt::Euclid 0.2.4 qw(:vars);

my $list = $ARGV_infile;
my $results_path = $ARGV_results_path;
my $queue = $ARGV_queue;
my $config = $ARGV_config;
my $grid_code = $ARGV_project_code;
my $tag = $ARGV_project_tag;

my %SERVICE = (
	"UNIREF" => 1,
	"HMM3" => 1,
	"TMHMM" => 1,
	"LIPO" => 1,
	"HYPO" => 1,
);

my $cfg;
my @order;
if ($config) {
	$cfg = Config::IniFiles->new( -file => "$config" ) || die "cannot parse user suplied config file.\n";
	@order = $cfg->Sections();
	print "@order\n";
	foreach my $service (@order) {
		unless ($SERVICE{$service}) {
			die "$service is not a defined pipeline service, check $config for errors.\n";
		}
	}
} else {
	@order = ("UNIREF","HMM3","TMHMM","LIPO","HYPO");
}
	
my %EXECS = (
		UNIREF => "$FindBin::Bin/uniref_blastp.pl",
		HMM3 => "$FindBin::Bin/hmmpfam3.pl",
		TMHMM => "$FindBin::Bin/tmhmm.pl",
		LIPO => "$FindBin::Bin/lipoprotein.pl",
		HYPO => "$FindBin::Bin/hypothetical.pl",
		RULES => "$FindBin::Bin/rules.pl",
		SF => "$FindBin::Bin/fasta_splitter.pl",
);


foreach my $prog (keys %EXECS) {
	print "$prog\t$EXECS{$prog}\n";
}

my %dirs = (
	UNIREF => "$results_path/uniref_results",
	HMM3 => "$results_path/hmm3_results",
	TMHMM => "$results_path/tmhmm_results",
	LIPO => "$results_path/lipoprotein_results",
	HYPO => "$results_path/hypothetical_results",
	RULES => "$results_path/rules_results",
);

my $results_list = "$results_path/parsed_results.list";
open (RES_LIST, ">$results_list") || die "cannot open $results_list. $!\n"; 
foreach my $dir (@order) {
	print "Running $dir service...\n";
	&print_time("$dir STARTTIME");
	mkdir "$dirs{$dir}";
	my $cmd = $EXECS{$dir} . " -infile $list -results_path $dirs{$dir} -project_code $grid_code";
	if ($queue) {
		$cmd .= " -queue $queue";
	}
	if ($config) {
		$cmd .= " -config $config";
	}
	if ($tag && $dir eq "UNIREF") {
		$cmd .= " -project_tag $tag";
	}
	print "$cmd\n";
	system $cmd;
	my @list = `ls $dirs{$dir}/*.parsed`;
	foreach my $item (@list) {
		chomp $item;
		print RES_LIST "$item\n";
	}
	&print_time("$dir ENDTIME");
	print "Done with $dir service.\n";
}
close RES_LIST;

print "Running RULES service...\n";
&print_time("RULES STARTTIME");
mkdir "$dirs{RULES}";
my $cmd = $EXECS{RULES} . " -infile $results_list -results_path $dirs{RULES} -project_code $grid_code";
if ($queue) {
	$cmd .= " -queue $queue";
}
if ($config) {
	$cmd .= " -config $config";
}
print "$cmd\n";
system $cmd;
&print_time("RULES ENDTIME");
print "Done with RULES service.\n";